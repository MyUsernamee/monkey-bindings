// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: Cinemachine.CinemachineImpulseManager/EnvelopeDefinition
#include "Cinemachine/CinemachineImpulseManager_EnvelopeDefinition.hpp"
// Including type: Cinemachine.CinemachineImpulseManager/ImpulseEvent/DirectionMode
#include "Cinemachine/CinemachineImpulseManager_ImpulseEvent.hpp"
// Including type: Cinemachine.CinemachineImpulseManager/ImpulseEvent/DissipationMode
// Already included the same include: Cinemachine/CinemachineImpulseManager_ImpulseEvent.hpp
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
// Completed includes
// Begin forward declares
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: Vector3
  struct Vector3;
}
// Forward declaring namespace: Cinemachine
namespace Cinemachine {
  // Forward declaring type: SignalSourceAsset
  class SignalSourceAsset;
}
// Completed forward declares
// Type namespace: Cinemachine
namespace Cinemachine {
  // Forward declaring type: CinemachineImpulseDefinition
  class CinemachineImpulseDefinition;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::Cinemachine::CinemachineImpulseDefinition);
DEFINE_IL2CPP_ARG_TYPE(::Cinemachine::CinemachineImpulseDefinition*, "Cinemachine", "CinemachineImpulseDefinition");
// Type namespace: Cinemachine
namespace Cinemachine {
  // Size: 0x64
  #pragma pack(push, 1)
  // Autogenerated type: Cinemachine.CinemachineImpulseDefinition
  // [TokenAttribute] Offset: FFFFFFFF
  // [DocumentationSortingAttribute] Offset: AE62C4
  class CinemachineImpulseDefinition : public ::Il2CppObject {
    public:
    // Nested type: ::Cinemachine::CinemachineImpulseDefinition::RepeatMode
    struct RepeatMode;
    // Nested type: ::Cinemachine::CinemachineImpulseDefinition::SignalSource
    class SignalSource;
    // Size: 0x4
    #pragma pack(push, 1)
    // Autogenerated type: Cinemachine.CinemachineImpulseDefinition/RepeatMode
    // [TokenAttribute] Offset: FFFFFFFF
    struct RepeatMode/*, public ::System::Enum*/ {
      public:
      public:
      // public System.Int32 value__
      // Size: 0x4
      // Offset: 0x0
      int value;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      public:
      // Creating value type constructor for type: RepeatMode
      constexpr RepeatMode(int value_ = {}) noexcept : value{value_} {}
      // Creating interface conversion operator: operator ::System::Enum
      operator ::System::Enum() noexcept {
        return *reinterpret_cast<::System::Enum*>(this);
      }
      // Creating conversion operator: operator int
      constexpr operator int() const noexcept {
        return value;
      }
      // static field const value: static public Cinemachine.CinemachineImpulseDefinition/RepeatMode Stretch
      static constexpr const int Stretch = 0;
      // Get static field: static public Cinemachine.CinemachineImpulseDefinition/RepeatMode Stretch
      static ::Cinemachine::CinemachineImpulseDefinition::RepeatMode _get_Stretch();
      // Set static field: static public Cinemachine.CinemachineImpulseDefinition/RepeatMode Stretch
      static void _set_Stretch(::Cinemachine::CinemachineImpulseDefinition::RepeatMode value);
      // static field const value: static public Cinemachine.CinemachineImpulseDefinition/RepeatMode Loop
      static constexpr const int Loop = 1;
      // Get static field: static public Cinemachine.CinemachineImpulseDefinition/RepeatMode Loop
      static ::Cinemachine::CinemachineImpulseDefinition::RepeatMode _get_Loop();
      // Set static field: static public Cinemachine.CinemachineImpulseDefinition/RepeatMode Loop
      static void _set_Loop(::Cinemachine::CinemachineImpulseDefinition::RepeatMode value);
      // Get instance field reference: public System.Int32 value__
      [[deprecated("Use field access instead!")]] int& dyn_value__();
    }; // Cinemachine.CinemachineImpulseDefinition/RepeatMode
    #pragma pack(pop)
    static check_size<sizeof(CinemachineImpulseDefinition::RepeatMode), 0 + sizeof(int)> __Cinemachine_CinemachineImpulseDefinition_RepeatModeSizeCheck;
    static_assert(sizeof(CinemachineImpulseDefinition::RepeatMode) == 0x4);
    public:
    // [TooltipAttribute] Offset: 0xAEBE10
    // public System.Int32 m_ImpulseChannel
    // Size: 0x4
    // Offset: 0x10
    int m_ImpulseChannel;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // Padding between fields: m_ImpulseChannel and: m_RawSignal
    char __padding0[0x4] = {};
    // [HeaderAttribute] Offset: 0xAEBE5C
    // [TooltipAttribute] Offset: 0xAEBE5C
    // [CinemachineEmbeddedAssetPropertyAttribute] Offset: 0xAEBE5C
    // public Cinemachine.SignalSourceAsset m_RawSignal
    // Size: 0x8
    // Offset: 0x18
    ::Cinemachine::SignalSourceAsset* m_RawSignal;
    // Field size check
    static_assert(sizeof(::Cinemachine::SignalSourceAsset*) == 0x8);
    // [TooltipAttribute] Offset: 0xAEBED0
    // public System.Single m_AmplitudeGain
    // Size: 0x4
    // Offset: 0x20
    float m_AmplitudeGain;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // [TooltipAttribute] Offset: 0xAEBF08
    // public System.Single m_FrequencyGain
    // Size: 0x4
    // Offset: 0x24
    float m_FrequencyGain;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // [TooltipAttribute] Offset: 0xAEBF40
    // public Cinemachine.CinemachineImpulseDefinition/RepeatMode m_RepeatMode
    // Size: 0x4
    // Offset: 0x28
    ::Cinemachine::CinemachineImpulseDefinition::RepeatMode m_RepeatMode;
    // Field size check
    static_assert(sizeof(::Cinemachine::CinemachineImpulseDefinition::RepeatMode) == 0x4);
    // [TooltipAttribute] Offset: 0xAEBF78
    // public System.Boolean m_Randomize
    // Size: 0x1
    // Offset: 0x2C
    bool m_Randomize;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: m_Randomize and: m_TimeEnvelope
    char __padding5[0x3] = {};
    // [TooltipAttribute] Offset: 0xAEBFB0
    // public Cinemachine.CinemachineImpulseManager/EnvelopeDefinition m_TimeEnvelope
    // Size: 0x1E
    // Offset: 0x30
    ::Cinemachine::CinemachineImpulseManager::EnvelopeDefinition m_TimeEnvelope;
    // Field size check
    static_assert(sizeof(::Cinemachine::CinemachineImpulseManager::EnvelopeDefinition) == 0x1E);
    // Padding between fields: m_TimeEnvelope and: m_ImpactRadius
    char __padding6[0x2] = {};
    // [HeaderAttribute] Offset: 0xAEBFFC
    // [TooltipAttribute] Offset: 0xAEBFFC
    // public System.Single m_ImpactRadius
    // Size: 0x4
    // Offset: 0x50
    float m_ImpactRadius;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // [TooltipAttribute] Offset: 0xAEC05C
    // public Cinemachine.CinemachineImpulseManager/ImpulseEvent/DirectionMode m_DirectionMode
    // Size: 0x4
    // Offset: 0x54
    ::Cinemachine::CinemachineImpulseManager::ImpulseEvent::DirectionMode m_DirectionMode;
    // Field size check
    static_assert(sizeof(::Cinemachine::CinemachineImpulseManager::ImpulseEvent::DirectionMode) == 0x4);
    // [TooltipAttribute] Offset: 0xAEC094
    // public Cinemachine.CinemachineImpulseManager/ImpulseEvent/DissipationMode m_DissipationMode
    // Size: 0x4
    // Offset: 0x58
    ::Cinemachine::CinemachineImpulseManager::ImpulseEvent::DissipationMode m_DissipationMode;
    // Field size check
    static_assert(sizeof(::Cinemachine::CinemachineImpulseManager::ImpulseEvent::DissipationMode) == 0x4);
    // [TooltipAttribute] Offset: 0xAEC0CC
    // public System.Single m_DissipationDistance
    // Size: 0x4
    // Offset: 0x5C
    float m_DissipationDistance;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // [TooltipAttribute] Offset: 0xAEC104
    // public System.Single m_PropagationSpeed
    // Size: 0x4
    // Offset: 0x60
    float m_PropagationSpeed;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    public:
    // Get instance field reference: public System.Int32 m_ImpulseChannel
    [[deprecated("Use field access instead!")]] int& dyn_m_ImpulseChannel();
    // Get instance field reference: public Cinemachine.SignalSourceAsset m_RawSignal
    [[deprecated("Use field access instead!")]] ::Cinemachine::SignalSourceAsset*& dyn_m_RawSignal();
    // Get instance field reference: public System.Single m_AmplitudeGain
    [[deprecated("Use field access instead!")]] float& dyn_m_AmplitudeGain();
    // Get instance field reference: public System.Single m_FrequencyGain
    [[deprecated("Use field access instead!")]] float& dyn_m_FrequencyGain();
    // Get instance field reference: public Cinemachine.CinemachineImpulseDefinition/RepeatMode m_RepeatMode
    [[deprecated("Use field access instead!")]] ::Cinemachine::CinemachineImpulseDefinition::RepeatMode& dyn_m_RepeatMode();
    // Get instance field reference: public System.Boolean m_Randomize
    [[deprecated("Use field access instead!")]] bool& dyn_m_Randomize();
    // Get instance field reference: public Cinemachine.CinemachineImpulseManager/EnvelopeDefinition m_TimeEnvelope
    [[deprecated("Use field access instead!")]] ::Cinemachine::CinemachineImpulseManager::EnvelopeDefinition& dyn_m_TimeEnvelope();
    // Get instance field reference: public System.Single m_ImpactRadius
    [[deprecated("Use field access instead!")]] float& dyn_m_ImpactRadius();
    // Get instance field reference: public Cinemachine.CinemachineImpulseManager/ImpulseEvent/DirectionMode m_DirectionMode
    [[deprecated("Use field access instead!")]] ::Cinemachine::CinemachineImpulseManager::ImpulseEvent::DirectionMode& dyn_m_DirectionMode();
    // Get instance field reference: public Cinemachine.CinemachineImpulseManager/ImpulseEvent/DissipationMode m_DissipationMode
    [[deprecated("Use field access instead!")]] ::Cinemachine::CinemachineImpulseManager::ImpulseEvent::DissipationMode& dyn_m_DissipationMode();
    // Get instance field reference: public System.Single m_DissipationDistance
    [[deprecated("Use field access instead!")]] float& dyn_m_DissipationDistance();
    // Get instance field reference: public System.Single m_PropagationSpeed
    [[deprecated("Use field access instead!")]] float& dyn_m_PropagationSpeed();
    // public System.Void OnValidate()
    // Offset: 0xFC9200
    void OnValidate();
    // public System.Void CreateEvent(UnityEngine.Vector3 position, UnityEngine.Vector3 velocity)
    // Offset: 0xFC9358
    void CreateEvent(::UnityEngine::Vector3 position, ::UnityEngine::Vector3 velocity);
    // public Cinemachine.CinemachineImpulseManager/ImpulseEvent CreateAndReturnEvent(UnityEngine.Vector3 position, UnityEngine.Vector3 velocity)
    // Offset: 0xFC935C
    ::Cinemachine::CinemachineImpulseManager::ImpulseEvent* CreateAndReturnEvent(::UnityEngine::Vector3 position, ::UnityEngine::Vector3 velocity);
    // public System.Void .ctor()
    // Offset: 0xFC98A0
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static CinemachineImpulseDefinition* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Cinemachine::CinemachineImpulseDefinition::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<CinemachineImpulseDefinition*, creationType>()));
    }
  }; // Cinemachine.CinemachineImpulseDefinition
  #pragma pack(pop)
  static check_size<sizeof(CinemachineImpulseDefinition), 96 + sizeof(float)> __Cinemachine_CinemachineImpulseDefinitionSizeCheck;
  static_assert(sizeof(CinemachineImpulseDefinition) == 0x64);
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::Cinemachine::CinemachineImpulseDefinition::RepeatMode, "Cinemachine", "CinemachineImpulseDefinition/RepeatMode");
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: Cinemachine::CinemachineImpulseDefinition::OnValidate
// Il2CppName: OnValidate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Cinemachine::CinemachineImpulseDefinition::*)()>(&Cinemachine::CinemachineImpulseDefinition::OnValidate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Cinemachine::CinemachineImpulseDefinition*), "OnValidate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Cinemachine::CinemachineImpulseDefinition::CreateEvent
// Il2CppName: CreateEvent
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Cinemachine::CinemachineImpulseDefinition::*)(::UnityEngine::Vector3, ::UnityEngine::Vector3)>(&Cinemachine::CinemachineImpulseDefinition::CreateEvent)> {
  static const MethodInfo* get() {
    static auto* position = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* velocity = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Cinemachine::CinemachineImpulseDefinition*), "CreateEvent", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{position, velocity});
  }
};
// Writing MetadataGetter for method: Cinemachine::CinemachineImpulseDefinition::CreateAndReturnEvent
// Il2CppName: CreateAndReturnEvent
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Cinemachine::CinemachineImpulseManager::ImpulseEvent* (Cinemachine::CinemachineImpulseDefinition::*)(::UnityEngine::Vector3, ::UnityEngine::Vector3)>(&Cinemachine::CinemachineImpulseDefinition::CreateAndReturnEvent)> {
  static const MethodInfo* get() {
    static auto* position = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* velocity = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Cinemachine::CinemachineImpulseDefinition*), "CreateAndReturnEvent", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{position, velocity});
  }
};
// Writing MetadataGetter for method: Cinemachine::CinemachineImpulseDefinition::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
